<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rp2040-pac-0.6.0/src/uart0/uartrsr.rs`."><title>uartrsr.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="rp2040_pac" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0 (f6e511eec 2024-10-15)" data-channel="1.82.0" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../../../static.files/src-script-e66d777a5a92e9b2.js"></script><script defer src="../../../src-files.js"></script><script defer src="../../../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
<a href="#4" id="4">4</a>
<a href="#5" id="5">5</a>
<a href="#6" id="6">6</a>
<a href="#7" id="7">7</a>
<a href="#8" id="8">8</a>
<a href="#9" id="9">9</a>
<a href="#10" id="10">10</a>
<a href="#11" id="11">11</a>
<a href="#12" id="12">12</a>
<a href="#13" id="13">13</a>
<a href="#14" id="14">14</a>
<a href="#15" id="15">15</a>
<a href="#16" id="16">16</a>
<a href="#17" id="17">17</a>
<a href="#18" id="18">18</a>
<a href="#19" id="19">19</a>
<a href="#20" id="20">20</a>
<a href="#21" id="21">21</a>
<a href="#22" id="22">22</a>
<a href="#23" id="23">23</a>
<a href="#24" id="24">24</a>
<a href="#25" id="25">25</a>
<a href="#26" id="26">26</a>
<a href="#27" id="27">27</a>
<a href="#28" id="28">28</a>
<a href="#29" id="29">29</a>
<a href="#30" id="30">30</a>
<a href="#31" id="31">31</a>
<a href="#32" id="32">32</a>
<a href="#33" id="33">33</a>
<a href="#34" id="34">34</a>
<a href="#35" id="35">35</a>
<a href="#36" id="36">36</a>
<a href="#37" id="37">37</a>
<a href="#38" id="38">38</a>
<a href="#39" id="39">39</a>
<a href="#40" id="40">40</a>
<a href="#41" id="41">41</a>
<a href="#42" id="42">42</a>
<a href="#43" id="43">43</a>
<a href="#44" id="44">44</a>
<a href="#45" id="45">45</a>
<a href="#46" id="46">46</a>
<a href="#47" id="47">47</a>
<a href="#48" id="48">48</a>
<a href="#49" id="49">49</a>
<a href="#50" id="50">50</a>
<a href="#51" id="51">51</a>
<a href="#52" id="52">52</a>
<a href="#53" id="53">53</a>
<a href="#54" id="54">54</a>
<a href="#55" id="55">55</a>
<a href="#56" id="56">56</a>
<a href="#57" id="57">57</a>
<a href="#58" id="58">58</a>
<a href="#59" id="59">59</a>
<a href="#60" id="60">60</a>
<a href="#61" id="61">61</a>
<a href="#62" id="62">62</a>
<a href="#63" id="63">63</a>
<a href="#64" id="64">64</a>
<a href="#65" id="65">65</a>
<a href="#66" id="66">66</a>
<a href="#67" id="67">67</a>
<a href="#68" id="68">68</a>
<a href="#69" id="69">69</a>
<a href="#70" id="70">70</a>
<a href="#71" id="71">71</a>
<a href="#72" id="72">72</a>
<a href="#73" id="73">73</a>
<a href="#74" id="74">74</a>
<a href="#75" id="75">75</a>
<a href="#76" id="76">76</a>
<a href="#77" id="77">77</a>
<a href="#78" id="78">78</a>
<a href="#79" id="79">79</a>
<a href="#80" id="80">80</a>
<a href="#81" id="81">81</a>
<a href="#82" id="82">82</a>
<a href="#83" id="83">83</a>
<a href="#84" id="84">84</a>
<a href="#85" id="85">85</a>
<a href="#86" id="86">86</a>
<a href="#87" id="87">87</a>
<a href="#88" id="88">88</a>
<a href="#89" id="89">89</a>
<a href="#90" id="90">90</a>
<a href="#91" id="91">91</a>
<a href="#92" id="92">92</a>
<a href="#93" id="93">93</a>
<a href="#94" id="94">94</a>
<a href="#95" id="95">95</a>
<a href="#96" id="96">96</a>
</pre></div><pre class="rust"><code><span class="attr">#[doc = <span class="string">"Register `UARTRSR` reader"</span>]
</span><span class="kw">pub type </span>R = <span class="kw">crate</span>::R&lt;UARTRSR_SPEC&gt;;
<span class="attr">#[doc = <span class="string">"Register `UARTRSR` writer"</span>]
</span><span class="kw">pub type </span>W = <span class="kw">crate</span>::W&lt;UARTRSR_SPEC&gt;;
<span class="attr">#[doc = <span class="string">"Field `FE` reader - Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO."</span>]
</span><span class="kw">pub type </span>FE_R = <span class="kw">crate</span>::BitReader;
<span class="attr">#[doc = <span class="string">"Field `FE` writer - Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO."</span>]
</span><span class="kw">pub type </span>FE_W&lt;<span class="lifetime">'a</span>, REG&gt; = <span class="kw">crate</span>::BitWriter1C&lt;<span class="lifetime">'a</span>, REG&gt;;
<span class="attr">#[doc = <span class="string">"Field `PE` reader - Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO."</span>]
</span><span class="kw">pub type </span>PE_R = <span class="kw">crate</span>::BitReader;
<span class="attr">#[doc = <span class="string">"Field `PE` writer - Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO."</span>]
</span><span class="kw">pub type </span>PE_W&lt;<span class="lifetime">'a</span>, REG&gt; = <span class="kw">crate</span>::BitWriter1C&lt;<span class="lifetime">'a</span>, REG&gt;;
<span class="attr">#[doc = <span class="string">"Field `BE` reader - Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity, and stop bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received."</span>]
</span><span class="kw">pub type </span>BE_R = <span class="kw">crate</span>::BitReader;
<span class="attr">#[doc = <span class="string">"Field `BE` writer - Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity, and stop bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received."</span>]
</span><span class="kw">pub type </span>BE_W&lt;<span class="lifetime">'a</span>, REG&gt; = <span class="kw">crate</span>::BitWriter1C&lt;<span class="lifetime">'a</span>, REG&gt;;
<span class="attr">#[doc = <span class="string">"Field `OE` reader - Overrun error. This bit is set to 1 if data is received and the FIFO is already full. This bit is cleared to 0 by a write to UARTECR. The FIFO contents remain valid because no more data is written when the FIFO is full, only the contents of the shift register are overwritten. The CPU must now read the data, to empty the FIFO."</span>]
</span><span class="kw">pub type </span>OE_R = <span class="kw">crate</span>::BitReader;
<span class="attr">#[doc = <span class="string">"Field `OE` writer - Overrun error. This bit is set to 1 if data is received and the FIFO is already full. This bit is cleared to 0 by a write to UARTECR. The FIFO contents remain valid because no more data is written when the FIFO is full, only the contents of the shift register are overwritten. The CPU must now read the data, to empty the FIFO."</span>]
</span><span class="kw">pub type </span>OE_W&lt;<span class="lifetime">'a</span>, REG&gt; = <span class="kw">crate</span>::BitWriter1C&lt;<span class="lifetime">'a</span>, REG&gt;;
<span class="kw">impl </span>R {
    <span class="attr">#[doc = <span class="string">"Bit 0 - Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO."</span>]
    #[inline(always)]
    </span><span class="kw">pub fn </span>fe(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; FE_R {
        FE_R::new((<span class="self">self</span>.bits &amp; <span class="number">1</span>) != <span class="number">0</span>)
    }
    <span class="attr">#[doc = <span class="string">"Bit 1 - Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO."</span>]
    #[inline(always)]
    </span><span class="kw">pub fn </span>pe(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; PE_R {
        PE_R::new(((<span class="self">self</span>.bits &gt;&gt; <span class="number">1</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)
    }
    <span class="attr">#[doc = <span class="string">"Bit 2 - Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity, and stop bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received."</span>]
    #[inline(always)]
    </span><span class="kw">pub fn </span>be(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; BE_R {
        BE_R::new(((<span class="self">self</span>.bits &gt;&gt; <span class="number">2</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)
    }
    <span class="attr">#[doc = <span class="string">"Bit 3 - Overrun error. This bit is set to 1 if data is received and the FIFO is already full. This bit is cleared to 0 by a write to UARTECR. The FIFO contents remain valid because no more data is written when the FIFO is full, only the contents of the shift register are overwritten. The CPU must now read the data, to empty the FIFO."</span>]
    #[inline(always)]
    </span><span class="kw">pub fn </span>oe(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; OE_R {
        OE_R::new(((<span class="self">self</span>.bits &gt;&gt; <span class="number">3</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)
    }
}
<span class="kw">impl </span>W {
    <span class="attr">#[doc = <span class="string">"Bit 0 - Framing error. When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1). This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO."</span>]
    #[inline(always)]
    #[must_use]
    </span><span class="kw">pub fn </span>fe(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; FE_W&lt;UARTRSR_SPEC&gt; {
        FE_W::new(<span class="self">self</span>, <span class="number">0</span>)
    }
    <span class="attr">#[doc = <span class="string">"Bit 1 - Parity error. When set to 1, it indicates that the parity of the received data character does not match the parity that the EPS and SPS bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0 by a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO."</span>]
    #[inline(always)]
    #[must_use]
    </span><span class="kw">pub fn </span>pe(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; PE_W&lt;UARTRSR_SPEC&gt; {
        PE_W::new(<span class="self">self</span>, <span class="number">1</span>)
    }
    <span class="attr">#[doc = <span class="string">"Bit 2 - Break error. This bit is set to 1 if a break condition was detected, indicating that the received data input was held LOW for longer than a full-word transmission time (defined as start, data, parity, and stop bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode, this error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received."</span>]
    #[inline(always)]
    #[must_use]
    </span><span class="kw">pub fn </span>be(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; BE_W&lt;UARTRSR_SPEC&gt; {
        BE_W::new(<span class="self">self</span>, <span class="number">2</span>)
    }
    <span class="attr">#[doc = <span class="string">"Bit 3 - Overrun error. This bit is set to 1 if data is received and the FIFO is already full. This bit is cleared to 0 by a write to UARTECR. The FIFO contents remain valid because no more data is written when the FIFO is full, only the contents of the shift register are overwritten. The CPU must now read the data, to empty the FIFO."</span>]
    #[inline(always)]
    #[must_use]
    </span><span class="kw">pub fn </span>oe(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; OE_W&lt;UARTRSR_SPEC&gt; {
        OE_W::new(<span class="self">self</span>, <span class="number">3</span>)
    }
    <span class="attr">#[doc = <span class="string">r" Writes raw bits to the register."</span>]
    #[doc = <span class="string">r""</span>]
    #[doc = <span class="string">r" # Safety"</span>]
    #[doc = <span class="string">r""</span>]
    #[doc = <span class="string">r" Passing incorrect value can cause undefined behaviour. See reference manual"</span>]
    #[inline(always)]
    </span><span class="kw">pub unsafe fn </span>bits(<span class="kw-2">&amp;mut </span><span class="self">self</span>, bits: u32) -&gt; <span class="kw-2">&amp;mut </span><span class="self">Self </span>{
        <span class="self">self</span>.bits = bits;
        <span class="self">self
    </span>}
}
<span class="attr">#[doc = <span class="string">"Receive Status Register/Error Clear Register, UARTRSR/UARTECR  

You can [`read`](crate::generic::Reg::read) this register and get [`uartrsr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`uartrsr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."</span>]
</span><span class="kw">pub struct </span>UARTRSR_SPEC;
<span class="kw">impl </span><span class="kw">crate</span>::RegisterSpec <span class="kw">for </span>UARTRSR_SPEC {
    <span class="kw">type </span>Ux = u32;
}
<span class="attr">#[doc = <span class="string">"`read()` method returns [`uartrsr::R`](R) reader structure"</span>]
</span><span class="kw">impl </span><span class="kw">crate</span>::Readable <span class="kw">for </span>UARTRSR_SPEC {}
<span class="attr">#[doc = <span class="string">"`write(|w| ..)` method takes [`uartrsr::W`](W) writer structure"</span>]
</span><span class="kw">impl </span><span class="kw">crate</span>::Writable <span class="kw">for </span>UARTRSR_SPEC {
    <span class="kw">const </span>ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = <span class="number">0</span>;
    <span class="kw">const </span>ONE_TO_MODIFY_FIELDS_BITMAP: u32 = <span class="number">0x0f</span>;
}
<span class="attr">#[doc = <span class="string">"`reset()` method sets UARTRSR to value 0"</span>]
</span><span class="kw">impl </span><span class="kw">crate</span>::Resettable <span class="kw">for </span>UARTRSR_SPEC {
    <span class="kw">const </span>RESET_VALUE: u32 = <span class="number">0</span>;
}
</code></pre></div></section></main></body></html>